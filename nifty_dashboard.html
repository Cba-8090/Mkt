<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nifty Unified Trading Dashboard</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0f1419 0%, #1a2332 100%);
            color: #ffffff;
            overflow-x: hidden;
        }

        .dashboard-container {
            max-width: 1920px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #00d4ff, #00ff88);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .status-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            flex-wrap: wrap;
            gap: 20px;
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        .status-indicator.live {
            background: #00ff88;
        }

        .status-indicator.warning {
            background: #ffaa00;
        }

        .status-indicator.error {
            background: #ff4444;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .main-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: auto auto auto;
            gap: 20px;
            margin-bottom: 30px;
        }

        .card {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0, 212, 255, 0.2);
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding-bottom: 10px;
        }

        .card-title {
            font-size: 1.2em;
            font-weight: 600;
            color: #00d4ff;
        }

        .weight-badge {
            background: linear-gradient(45deg, #00d4ff, #0099cc);
            color: white;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.8em;
            font-weight: bold;
        }

        .futures-card {
            grid-column: 1;
            grid-row: 1;
        }

        .options-card {
            grid-column: 2;
            grid-row: 1;
        }

        .gamma-card {
            grid-column: 1;
            grid-row: 2;
        }

        .spot-card {
            grid-column: 2;
            grid-row: 2;
        }

        .signals-card {
            grid-column: 1 / -1;
            grid-row: 3;
        }

        .metric-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 10px 0;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .metric-label {
            color: #cccccc;
            font-size: 0.9em;
        }

        .metric-value {
            font-weight: bold;
            font-size: 1.1em;
        }

        .positive {
            color: #00ff88;
        }

        .negative {
            color: #ff4444;
        }

        .neutral {
            color: #ffaa00;
        }

        .signal-display {
            text-align: center;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
        }

        .signal-bullish {
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.2), rgba(0, 255, 136, 0.1));
            border: 2px solid #00ff88;
        }

        .signal-bearish {
            background: linear-gradient(135deg, rgba(255, 68, 68, 0.2), rgba(255, 68, 68, 0.1));
            border: 2px solid #ff4444;
        }

        .signal-neutral {
            background: linear-gradient(135deg, rgba(255, 170, 0, 0.2), rgba(255, 170, 0, 0.1));
            border: 2px solid #ffaa00;
        }

        .signal-direction {
            font-size: 2em;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .signal-strength {
            font-size: 1.2em;
            margin-bottom: 5px;
        }

        .signal-confidence {
            font-size: 1em;
            opacity: 0.8;
        }

        .chart-container {
            height: 200px;
            margin-top: 15px;
        }

        /* Enhanced chart container for gamma and spot cards */
        .enhanced-chart-container {
            height: 150px;
            margin-top: 10px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            padding: 10px;
        }

        .breakdown-signals {
            margin-top: 15px;
        }

        .breakdown-item {
            background: rgba(255, 68, 68, 0.1);
            border-left: 4px solid #ff4444;
            padding: 10px;
            margin: 8px 0;
            border-radius: 5px;
            font-size: 0.9em;
        }

        .breakdown-time {
            color: #00d4ff;
            font-weight: bold;
        }

        .price-reversals {
            margin-top: 15px;
        }

        .reversal-item {
            background: rgba(255, 255, 255, 0.05);
            padding: 8px;
            margin: 5px 0;
            border-radius: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .reversal-bullish {
            border-left: 4px solid #00ff88;
        }

        .reversal-bearish {
            border-left: 4px solid #ff4444;
        }

        .levels-display {
            display: flex;
            gap: 20px;
            margin-top: 15px;
        }

        .levels-column {
            flex: 1;
        }

        .level-item {
            background: rgba(255, 255, 255, 0.05);
            padding: 5px 10px;
            margin: 3px 0;
            border-radius: 5px;
            text-align: center;
        }

        .support-level {
            border-left: 4px solid #00ff88;
        }

        .resistance-level {
            border-left: 4px solid #ff4444;
        }

        .refresh-btn {
            background: linear-gradient(45deg, #00d4ff, #00ff88);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 25px;
            cursor: pointer;
            font-weight: bold;
            transition: transform 0.2s ease;
        }

        .refresh-btn:hover {
            transform: scale(1.05);
        }

        .auto-refresh {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .toggle-switch {
            position: relative;
            width: 50px;
            height: 25px;
            background: #555;
            border-radius: 25px;
            cursor: pointer;
            transition: background 0.3s ease;
        }

        .toggle-switch.active {
            background: #00ff88;
        }

        .toggle-slider {
            position: absolute;
            top: 2px;
            left: 2px;
            width: 21px;
            height: 21px;
            background: white;
            border-radius: 50%;
            transition: transform 0.3s ease;
        }

        .toggle-switch.active .toggle-slider {
            transform: translateX(25px);
        }

        .timestamp {
            font-size: 0.9em;
            color: #999;
        }

        /* Chart title styling */
        .chart-title {
            font-size: 0.9em;
            color: #00d4ff;
            text-align: center;
            margin-bottom: 5px;
            font-weight: 600;
        }

        @media (max-width: 1024px) {
            .main-grid {
                grid-template-columns: 1fr;
                grid-template-rows: auto;
            }

            .signals-card {
                grid-column: 1;
            }

            .status-bar {
                flex-direction: column;
                align-items: flex-start;
            }
        }
    </style>
</head>
<body>
    <div class="dashboard-container">
        <div class="header">
            <h1>NIFTY UNIFIED TRADING DASHBOARD</h1>
            <div class="status-bar">
                <div class="status-item">
                    <div class="status-indicator live" id="connectionStatus"></div>
                    <span id="connectionText">Live Data</span>
                </div>
                <div class="status-item">
                    <span>Last Update: </span>
                    <span class="timestamp" id="lastUpdate">--:--:--</span>
                </div>
                <div class="status-item auto-refresh">
                    <span>Auto Refresh:</span>
                    <div class="toggle-switch active" id="autoRefreshToggle">
                        <div class="toggle-slider"></div>
                    </div>
                </div>
                <div class="status-item">
                    <button class="refresh-btn" onclick="fetchData()">Refresh Now</button>
                </div>
            </div>
        </div>

        <div class="main-grid">
            <!-- Futures Money Flow Card -->
            <div class="card futures-card">
                <div class="card-header">
                    <div class="card-title">Futures Money Flow</div>
                    <div class="weight-badge">70% Weight</div>
                </div>
                <div class="metric-row">
                    <span class="metric-label">Weighted Money Flow</span>
                    <span class="metric-value" id="weightedMoneyFlow">--</span>
                </div>
                <div class="metric-row">
                    <span class="metric-label">Positive Flow</span>
                    <span class="metric-value positive" id="positiveFlow">--</span>
                </div>
                <div class="metric-row">
                    <span class="metric-label">Negative Flow</span>
                    <span class="metric-value negative" id="negativeFlow">--</span>
                </div>
                <div class="metric-row">
                    <span class="metric-label">Cumulative Flow</span>
                    <span class="metric-value" id="cumulativeFlow">--</span>
                </div>
                <div class="chart-container">
                    <canvas id="futuresChart"></canvas>
                </div>
            </div>

            <!-- Options Flow Card -->
            <div class="card options-card">
                <div class="card-header">
                    <div class="card-title">Options Flow</div>
                    <div class="weight-badge">30% Weight</div>
                </div>
                <div class="metric-row">
                    <span class="metric-label">Net Flow</span>
                    <span class="metric-value" id="netFlow">--</span>
                </div>
                <div class="metric-row">
                    <span class="metric-label">Sentiment</span>
                    <span class="metric-value" id="sentiment">--</span>
                </div>
                <div class="metric-row">
                    <span class="metric-label">Bullish Flow</span>
                    <span class="metric-value positive" id="bullishFlow">--</span>
                </div>
                <div class="metric-row">
                    <span class="metric-label">Bearish Flow</span>
                    <span class="metric-value negative" id="bearishFlow">--</span>
                </div>
                <div class="chart-container">
                    <canvas id="optionsChart"></canvas>
                </div>
            </div>

            <!-- Gamma Analysis Card -->
            <div class="card gamma-card">
                <div class="card-header">
                    <div class="card-title">Gamma Analysis</div>
                </div>
                <div class="metric-row">
                    <span class="metric-label">Support Pressure</span>
                    <span class="metric-value positive" id="supportPressure">--</span>
                </div>
                <div class="metric-row">
                    <span class="metric-label">Resistance Pressure</span>
                    <span class="metric-value negative" id="resistancePressure">--</span>
                </div>
                <div class="metric-row">
                    <span class="metric-label">S/R Ratio</span>
                    <span class="metric-value" id="srRatio">--</span>
                </div>
                <div class="metric-row">
                    <span class="metric-label">Max Pressure Strike</span>
                    <span class="metric-value" id="maxPressureStrike">--</span>
                </div>

                <!-- S/R Ratio Chart -->
                <div class="enhanced-chart-container">
                    <div class="chart-title">S/R Ratio Trend</div>
                    <canvas id="srRatioChart"></canvas>
                </div>

                <div class="levels-display">
                    <div class="levels-column">
                        <h4 style="color: #00ff88; margin-bottom: 10px;">Support Levels</h4>
                        <div id="supportLevels"></div>
                    </div>
                    <div class="levels-column">
                        <h4 style="color: #ff4444; margin-bottom: 10px;">Resistance Levels</h4>
                        <div id="resistanceLevels"></div>
                    </div>
                </div>
                <div class="breakdown-signals" id="breakdownSignals"></div>
            </div>

            <!-- Spot Price Card -->
            <div class="card spot-card">
                <div class="card-header">
                    <div class="card-title">Spot Price</div>
                </div>
                <div class="metric-row">
                    <span class="metric-label">Current Price</span>
                    <span class="metric-value" id="spotPrice">--</span>
                </div>
                <div class="metric-row">
                    <span class="metric-label">Change</span>
                    <span class="metric-value" id="priceChange">--</span>
                </div>
                <div class="metric-row">
                    <span class="metric-label">Change %</span>
                    <span class="metric-value" id="priceChangePercent">--</span>
                </div>
                <div class="metric-row">
                    <span class="metric-label">Trend Direction</span>
                    <span class="metric-value" id="trendDirection">--</span>
                </div>

                <!-- Spot Price Chart -->
                <div class="enhanced-chart-container">
                    <div class="chart-title">Spot Price Movement</div>
                    <canvas id="spotPriceChart"></canvas>
                </div>

                <div class="price-reversals" id="priceReversals"></div>
            </div>

            <!-- Combined Signals Card -->
            <div class="card signals-card">
                <div class="card-header">
                    <div class="card-title">Combined Signals (70% Futures + 30% Options)</div>
                </div>
                <div class="signal-display" id="signalDisplay">
                    <div class="signal-direction" id="signalDirection">NEUTRAL</div>
                    <div class="signal-strength">Strength: <span id="signalStrength">0.0</span>/10</div>
                    <div class="signal-confidence">Confidence: <span id="signalConfidence">0</span>%</div>
                </div>
                <div class="chart-container">
                    <canvas id="combinedChart"></canvas>
                </div>
            </div>
        </div>
    </div>

   <script>
    // Enhanced global variables for persistence
    let autoRefresh = true;
    let refreshInterval;
    let futuresChart, optionsChart, combinedChart, srRatioChart, spotPriceChart;
    let historicalData = [];
    let allBreakdownSignals = []; // Persistent breakdown signals
    let allPriceReversals = [];   // Persistent price reversals

    // Local storage keys for persistence
    const STORAGE_KEYS = {
        HISTORICAL_DATA: 'nifty_historical_data',
        BREAKDOWN_SIGNALS: 'nifty_breakdown_signals',
        PRICE_REVERSALS: 'nifty_price_reversals',
        LAST_REFRESH: 'nifty_last_refresh'
    };

    // Enhanced initialization
    document.addEventListener('DOMContentLoaded', function() {
        loadPersistedData();
        initializeCharts();
        setupEventListeners();
        fetchEnhancedData();
        startAutoRefresh();
    });

    // Load persisted data from localStorage
    function loadPersistedData() {
        try {
            // Load historical chart data
            const storedHistoricalData = localStorage.getItem(STORAGE_KEYS.HISTORICAL_DATA);
            if (storedHistoricalData) {
                historicalData = JSON.parse(storedHistoricalData);
                console.log(`📊 Loaded ${historicalData.length} historical data points`);
            }

            // Load breakdown signals
            const storedBreakdownSignals = localStorage.getItem(STORAGE_KEYS.BREAKDOWN_SIGNALS);
            if (storedBreakdownSignals) {
                allBreakdownSignals = JSON.parse(storedBreakdownSignals);
                console.log(`⚠️ Loaded ${allBreakdownSignals.length} breakdown signals`);
            }

            // Load price reversals
            const storedPriceReversals = localStorage.getItem(STORAGE_KEYS.PRICE_REVERSALS);
            if (storedPriceReversals) {
                allPriceReversals = JSON.parse(storedPriceReversals);
                console.log(`🔄 Loaded ${allPriceReversals.length} price reversals`);
            }

            // Restore charts with historical data
            if (historicalData.length > 0) {
                setTimeout(() => restoreChartsFromHistoricalData(), 1000);
            }

        } catch (error) {
            console.error('Error loading persisted data:', error);
        }
    }

    // Save data to localStorage
    function saveDataToPersistence() {
        try {
            // Keep only last 100 data points to avoid storage limits
            const dataToSave = historicalData.slice(-100);
            localStorage.setItem(STORAGE_KEYS.HISTORICAL_DATA, JSON.stringify(dataToSave));

            // Keep only last 50 breakdown signals
            const signalsToSave = allBreakdownSignals.slice(-50);
            localStorage.setItem(STORAGE_KEYS.BREAKDOWN_SIGNALS, JSON.stringify(signalsToSave));

            // Keep only last 30 price reversals
            const reversalsToSave = allPriceReversals.slice(-30);
            localStorage.setItem(STORAGE_KEYS.PRICE_REVERSALS, JSON.stringify(reversalsToSave));

            localStorage.setItem(STORAGE_KEYS.LAST_REFRESH, new Date().toISOString());

        } catch (error) {
            console.error('Error saving data to persistence:', error);
        }
    }

    // Enhanced fetch data function
    async function fetchEnhancedData() {
        try {
            updateConnectionStatus('live', 'Fetching Enhanced Data...');

            // Try to fetch enhanced data first
            const data = await fetchEnhancedDataFromBackend();
            updateDashboardWithPersistence(data);

            updateConnectionStatus('live', 'Live Data');
            updateTimestamp();

        } catch (error) {
            console.error('Error fetching enhanced data:', error);
            updateConnectionStatus('error', 'Connection Error');

            // Fallback to regular data
            try {
                const data = await fetchDataFromBackend();
                updateDashboardWithPersistence(data);
            } catch (fallbackError) {
                console.error('Fallback data fetch failed:', fallbackError);
            }
        }
    }

    // Fetch enhanced data from backend
    async function fetchEnhancedDataFromBackend() {
        try {
            const response = await fetch('/api/enhanced-data');
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            return await response.json();
        } catch (error) {
            console.error('Enhanced backend fetch error:', error);
            // Fallback to regular endpoint
            return await fetchDataFromBackend();
        }
    }

    // Enhanced dashboard update with persistence
    function updateDashboardWithPersistence(data) {
        // Update regular dashboard elements
        updateDashboard(data);

        // Enhanced breakdown signals handling
        if (data.historical_breakdown_signals && data.historical_breakdown_signals.length > 0) {
            // Merge with existing signals, avoiding duplicates
            mergeBreakdownSignals(data.historical_breakdown_signals);
            updateBreakdownSignalsWithHistory();
        } else if (data.gamma_data && data.gamma_data.breakdown_signals) {
            // Use current signals if no historical data
            mergeBreakdownSignals(data.gamma_data.breakdown_signals);
            updateBreakdownSignalsWithHistory();
        }

        // Enhanced price reversals handling
        if (data.recent_price_reversals && data.recent_price_reversals.length > 0) {
            mergePriceReversals(data.recent_price_reversals);
            updatePriceReversalsWithHistory();
        } else if (data.gamma_data && data.gamma_data.price_reversals) {
            mergePriceReversals(data.gamma_data.price_reversals);
            updatePriceReversalsWithHistory();
        }

        // Store historical data
        historicalData.push(data);
        if (historicalData.length > 100) {
            historicalData = historicalData.slice(-100);
        }

        // Save to persistence every 5 updates
        if (historicalData.length % 5 === 0) {
            saveDataToPersistence();
        }

        // Update persistence status
        updatePersistenceStatus();
    }

    // Merge breakdown signals avoiding duplicates
    function mergeBreakdownSignals(newSignals) {
        for (const signal of newSignals) {
            // Create unique key
            const key = `${signal.time}-${signal.signal.substring(0, 30)}`;

            // Check if already exists
            const exists = allBreakdownSignals.some(existing =>
                `${existing.time}-${existing.signal.substring(0, 30)}` === key
            );

            if (!exists) {
                allBreakdownSignals.push({
                    ...signal,
                    timestamp: new Date().toISOString()
                });
            }
        }

        // Keep only last 50 signals
        if (allBreakdownSignals.length > 50) {
            allBreakdownSignals = allBreakdownSignals.slice(-50);
        }
    }

    // Merge price reversals avoiding duplicates
    function mergePriceReversals(newReversals) {
        for (const reversal of newReversals) {
            // Create unique key
            const key = `${reversal.time}-${reversal.direction}-${reversal.price}`;

            // Check if already exists
            const exists = allPriceReversals.some(existing =>
                `${existing.time}-${existing.direction}-${existing.price}` === key
            );

            if (!exists) {
                allPriceReversals.push({
                    ...reversal,
                    timestamp: new Date().toISOString()
                });
            }
        }

        // Keep only last 30 reversals
        if (allPriceReversals.length > 30) {
            allPriceReversals = allPriceReversals.slice(-30);
        }
    }

    // Update breakdown signals with historical context
    function updateBreakdownSignalsWithHistory() {
        const container = document.getElementById('breakdownSignals');

        // Sort signals by time (most recent first)
        const sortedSignals = allBreakdownSignals
            .slice(-15) // Last 15 signals
            .sort((a, b) => b.time.localeCompare(a.time));

        if (sortedSignals.length === 0) {
            container.innerHTML = '<div style="color: #00ff88; text-align: center;">No Breakdown Signals</div>';
            return;
        }

        container.innerHTML = `
            <h4 style="color: #ff4444; margin-bottom: 10px;">
                ⚠️ Breakdown Signals (${sortedSignals.length}/50 stored)
            </h4>` +
            sortedSignals.map(signal => {
                let typeColor = '#ff4444';
                let typeIcon = '⚠️';

                switch(signal.type) {
                    case 'CRITICAL':
                        typeColor = '#ff0000';
                        typeIcon = '🚨';
                        break;
                    case 'CONFIRMATION':
                        typeColor = '#ff6600';
                        typeIcon = '✅';
                        break;
                    case 'WARNING':
                        typeColor = '#ffaa00';
                        typeIcon = '⚠️';
                        break;
                    case 'EROSION':
                        typeColor = '#ff4444';
                        typeIcon = '📉';
                        break;
                    case 'REVERSAL':
                        typeColor = '#ff8800';
                        typeIcon = '🔄';
                        break;
                }

                return `<div class="breakdown-item" style="border-left-color: ${typeColor}; margin-bottom: 8px;">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <span class="breakdown-time" style="color: #00d4ff; font-weight: bold;">${signal.time}</span>
                        <span style="color: ${typeColor}; font-size: 1.1em;">${typeIcon}</span>
                    </div>
                    <div style="margin-top: 4px; font-size: 0.85em; line-height: 1.3;">${signal.signal}</div>
                </div>`;
            }).join('');
    }

    // Fetch data from backend
    async function fetchDataFromBackend() {
        const response = await fetch('/api/unified-data');
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        return await response.json();
    }

    // Update dashboard with data
    function updateDashboard(data) {
        if (!data) return;

        // Update futures data
        if (data.futures_data) {
            updateElement('weightedMoneyFlow', formatNumber(data.futures_data.weighted_money_flow));
            updateElement('positiveFlow', formatNumber(data.futures_data.weighted_positive_money_flow));
            updateElement('negativeFlow', formatNumber(data.futures_data.weighted_negative_money_flow));
            updateElement('cumulativeFlow', formatNumber(data.futures_data.cumulative_weighted_money_flow));
        }

        // Update options data
        if (data.options_data) {
            updateElement('netFlow', formatNumber(data.options_data.net_flow));
            updateElement('sentiment', data.options_data.sentiment);
            updateElement('bullishFlow', formatNumber(data.options_data.bullish_flow));
            updateElement('bearishFlow', formatNumber(data.options_data.bearish_flow));
        }

        // Update gamma data
        if (data.gamma_data) {
            updateElement('supportPressure', formatNumber(data.gamma_data.support_pressure));
            updateElement('resistancePressure', formatNumber(data.gamma_data.resistance_pressure));
            updateElement('srRatio', data.gamma_data.sr_ratio?.toFixed(2));
            updateElement('maxPressureStrike', formatNumber(data.gamma_data.max_pressure_strike));

            updateSupportResistanceLevels(data.gamma_data);
            updateBreakdownSignals(data.gamma_data.breakdown_signals || []);
        }

        // Update spot data
        if (data.spot_data) {
            updateElement('spotPrice', formatNumber(data.spot_data.spot_price));
            updateElement('priceChange', formatNumber(data.spot_data.price_change, true));
            updateElement('priceChangePercent', `${data.spot_data.price_change_pct?.toFixed(2)}%`);
        }

        if (data.gamma_data) {
            updateElement('trendDirection', data.gamma_data.trend_direction);
            updatePriceReversals(data.gamma_data.price_reversals || []);
        }

        // Update signals
        if (data.signals) {
            updateSignalDisplay(data.signals);
        }

        // Update charts
        updateCharts(data);
    }

    // Helper function to update elements
    function updateElement(id, value) {
        const element = document.getElementById(id);
        if (element && value !== undefined && value !== null) {
            element.textContent = value;

            // Add color classes based on value
            if (typeof value === 'string' && value.includes('-')) {
                element.className = 'metric-value negative';
            } else if (typeof value === 'number' && value > 0) {
                element.className = 'metric-value positive';
            } else {
                element.className = 'metric-value';
            }
        }
    }

    // Format numbers for display
    function formatNumber(value, showSign = false) {
        if (value === undefined || value === null || isNaN(value)) return '--';

        const sign = showSign && value > 0 ? '+' : '';

        if (Math.abs(value) >= 1000000) {
            return sign + (value / 1000000).toFixed(1) + 'M';
        } else if (Math.abs(value) >= 1000) {
            return sign + (value / 1000).toFixed(1) + 'K';
        } else {
            return sign + value.toFixed(0);
        }
    }

    // Update support and resistance levels
    function updateSupportResistanceLevels(gammaData) {
        const supportContainer = document.getElementById('supportLevels');
        const resistanceContainer = document.getElementById('resistanceLevels');

        if (supportContainer) {
            const supportLevels = gammaData.support_levels || [];
            supportContainer.innerHTML = supportLevels.length > 0 ?
                supportLevels.map(level => `<div class="level-item support-level">${formatNumber(level)}</div>`).join('') :
                '<div style="color: #999;">No support levels</div>';
        }

        if (resistanceContainer) {
            const resistanceLevels = gammaData.resistance_levels || [];
            resistanceContainer.innerHTML = resistanceLevels.length > 0 ?
                resistanceLevels.map(level => `<div class="level-item resistance-level">${formatNumber(level)}</div>`).join('') :
                '<div style="color: #999;">No resistance levels</div>';
        }
    }

    // Update breakdown signals
    function updateBreakdownSignals(signals) {
        const container = document.getElementById('breakdownSignals');
        if (!container) return;

        if (signals.length === 0) {
            container.innerHTML = '<div style="color: #00ff88; text-align: center;">No Breakdown Signals</div>';
            return;
        }

        container.innerHTML = '<h4 style="color: #ff4444; margin-bottom: 10px;">⚠️ Breakdown Signals</h4>' +
            signals.slice(-5).map(signal => // Show last 5 signals
                `<div class="breakdown-item">
                    <span class="breakdown-time">${signal.time}</span>
                    <div style="margin-top: 4px; font-size: 0.9em;">${signal.signal}</div>
                </div>`
            ).join('');
    }

    // Update price reversals
    function updatePriceReversals(reversals) {
        const container = document.getElementById('priceReversals');
        if (!container) return;

        if (reversals.length === 0) {
            container.innerHTML = '<h4 style="margin-bottom: 10px;">No Recent Reversals</h4>';
            return;
        }

        container.innerHTML = '<h4 style="margin-bottom: 10px;">Recent Price Reversals</h4>' +
            reversals.slice(-5).map(reversal => // Show last 5 reversals
                `<div class="reversal-item reversal-${reversal.direction.toLowerCase()}">
                    <span>${reversal.time} - ${reversal.direction}</span>
                    <span>${formatNumber(reversal.price)}</span>
                </div>`
            ).join('');
    }

    // Update signal display
    function updateSignalDisplay(signals) {
        const signalDisplay = document.getElementById('signalDisplay');
        const signalDirection = document.getElementById('signalDirection');
        const signalStrength = document.getElementById('signalStrength');
        const signalConfidence = document.getElementById('signalConfidence');

        if (signalDirection) signalDirection.textContent = signals.direction || 'NEUTRAL';
        if (signalStrength) signalStrength.textContent = signals.signal_strength?.toFixed(1) || '0.0';
        if (signalConfidence) signalConfidence.textContent = Math.round(signals.confidence || 0);

        // Update signal display styling
        if (signalDisplay) {
            signalDisplay.className = 'signal-display';

            if (signals.direction === 'Bullish') {
                signalDisplay.classList.add('signal-bullish');
            } else if (signals.direction === 'Bearish') {
                signalDisplay.classList.add('signal-bearish');
            } else {
                signalDisplay.classList.add('signal-neutral');
            }
        }
    }

    // Enhanced update charts function with new S/R Ratio and Spot Price charts
    function updateCharts(data) {
    const timeLabel = new Date().toLocaleTimeString();

    // Update enhanced futures chart with both datasets
    if (futuresChart && data.futures_data) {
        futuresChart.data.labels.push(timeLabel);

        // Update weighted money flow (primary dataset)
        futuresChart.data.datasets[0].data.push(data.futures_data.weighted_money_flow || 0);

        // Update cumulative money flow (secondary dataset)
        futuresChart.data.datasets[1].data.push(data.futures_data.cumulative_weighted_money_flow || 0);

        // Keep only last 20 data points
        if (futuresChart.data.labels.length > 20) {
            futuresChart.data.labels.shift();
            futuresChart.data.datasets[0].data.shift();
            futuresChart.data.datasets[1].data.shift();
        }

        futuresChart.update('none');
    }

    // Update options chart (unchanged)


    if (optionsChart && data.options_data) {
    optionsChart.data.labels.push(timeLabel);

    // Update both datasets
    optionsChart.data.datasets[0].data.push(data.options_data.net_flow || 0);
    optionsChart.data.datasets[1].data.push(data.options_data.total_flow || 0);
    optionsChart.data.datasets[2].data.push(data.options_data.bullish_flow || 0);    // Bullish Flow
    optionsChart.data.datasets[3].data.push(data.options_data.bearish_flow || 0);    // Bearish Flow

    // Keep only last 20 data points
    if (optionsChart.data.labels.length > 20) {
        optionsChart.data.labels.shift();
        optionsChart.data.datasets[0].data.shift();
        optionsChart.data.datasets[1].data.shift();
    }

        optionsChart.update('none');
    }


    // Update combined chart (unchanged)
    if (combinedChart && data.signals) {
        combinedChart.data.labels.push(timeLabel);
        combinedChart.data.datasets[0].data.push(data.signals.combined_signal || 0);

        // Keep only last 20 data points
        if (combinedChart.data.labels.length > 20) {
            combinedChart.data.labels.shift();
            combinedChart.data.datasets[0].data.shift();
        }

        combinedChart.update('none');
    }

    // Update S/R Ratio chart (unchanged)
    if (srRatioChart && data.gamma_data) {
        srRatioChart.data.labels.push(timeLabel);
        srRatioChart.data.datasets[0].data.push(data.gamma_data.sr_ratio || 0);

        // Keep only last 15 data points for smaller chart
        if (srRatioChart.data.labels.length > 15) {
            srRatioChart.data.labels.shift();
            srRatioChart.data.datasets[0].data.shift();
        }

        srRatioChart.update('none');
    }

    // Update Spot Price chart (unchanged)
    if (spotPriceChart && (data.spot_data || data.gamma_data)) {
        spotPriceChart.data.labels.push(timeLabel);
        const spotPrice = data.spot_data?.spot_price || data.gamma_data?.spot_price || 0;
        spotPriceChart.data.datasets[0].data.push(spotPrice);

        // Keep only last 15 data points for smaller chart
        if (spotPriceChart.data.labels.length > 15) {
            spotPriceChart.data.labels.shift();
            spotPriceChart.data.datasets[0].data.shift();
        }

        spotPriceChart.update('none');
    }
}


    // Update connection status
    function updateConnectionStatus(status, message) {
        const indicator = document.getElementById('connectionStatus');
        const text = document.getElementById('connectionText');

        if (indicator) {
            indicator.className = `status-indicator ${status}`;
        }

        if (text) {
            text.textContent = message;
        }
    }

    // Update timestamp
    function updateTimestamp() {
        const timestampElement = document.getElementById('lastUpdate');
        if (timestampElement) {
            timestampElement.textContent = new Date().toLocaleTimeString();
        }
    }

    // Initialize WebSocket (placeholder for future enhancement)
    function initializeWebSocket() {
        // WebSocket implementation would go here
        console.log('WebSocket initialization placeholder');
    }

    // Update price reversals with historical context
    function updatePriceReversalsWithHistory() {
        const container = document.getElementById('priceReversals');

        // Sort reversals by time (most recent first)
        const sortedReversals = allPriceReversals
            .slice(-10) // Last 10 reversals
            .sort((a, b) => b.time.localeCompare(a.time));

        if (sortedReversals.length === 0) {
            container.innerHTML = '<h4 style="margin-bottom: 10px;">No Recent Reversals</h4>';
            return;
        }

        container.innerHTML = `
            <h4 style="margin-bottom: 10px;">
                Recent Price Reversals (${sortedReversals.length}/30 stored)
            </h4>` +
            sortedReversals.map(reversal =>
                `<div class="reversal-item reversal-${reversal.direction.toLowerCase()}">
                    <span>${reversal.time} - ${reversal.direction}</span>
                    <span>${formatNumber(reversal.price)}</span>
                </div>`
            ).join('');
    }

    // Update persistence status
    function updatePersistenceStatus() {
        const statusDiv = document.createElement('div');
        statusDiv.style.cssText = 'font-size: 0.8em; color: #999; margin-top: 5px;';
        statusDiv.innerHTML = `
            📊 ${historicalData.length} data points |
            ⚠️ ${allBreakdownSignals.length} signals |
            🔄 ${allPriceReversals.length} reversals stored
        `;

        // Update or create persistence status
        const existingStatus = document.getElementById('persistenceStatus');
        if (existingStatus) {
            existingStatus.innerHTML = statusDiv.innerHTML;
        } else {
            statusDiv.id = 'persistenceStatus';
            const lastUpdate = document.getElementById('lastUpdate');
            if (lastUpdate && lastUpdate.parentNode) {
                lastUpdate.parentNode.appendChild(statusDiv);
            }
        }
    }

    // Restore charts from historical data
    function restoreChartsFromHistoricalData() {
    if (historicalData.length === 0) return;

    // Restore last 20 data points to charts
    const dataToRestore = historicalData.slice(-20);

    for (const data of dataToRestore) {
        const timeLabel = new Date(data.timestamp).toLocaleTimeString();

        // Restore enhanced futures chart with both datasets
        if (futuresChart && data.futures_data) {
            futuresChart.data.labels.push(timeLabel);
            futuresChart.data.datasets[0].data.push(data.futures_data.weighted_money_flow || 0);
            futuresChart.data.datasets[1].data.push(data.futures_data.cumulative_weighted_money_flow || 0);
        }

        // Restore options chart
        if (optionsChart && data.options_data) {
            optionsChart.data.labels.push(timeLabel);
            optionsChart.data.datasets[0].data.push(data.options_data.net_flow || 0);
            optionsChart.data.datasets[1].data.push(data.options_data.total_flow || 0);
        }

        // Restore combined chart
        if (combinedChart && data.signals) {
            combinedChart.data.labels.push(timeLabel);
            combinedChart.data.datasets[0].data.push(data.signals.combined_signal || 0);
        }

        // Restore S/R Ratio chart
        if (srRatioChart && data.gamma_data) {
            srRatioChart.data.labels.push(timeLabel);
            srRatioChart.data.datasets[0].data.push(data.gamma_data.sr_ratio || 0);
        }

        // Restore Spot Price chart
        if (spotPriceChart && (data.spot_data || data.gamma_data)) {
            spotPriceChart.data.labels.push(timeLabel);
            const spotPrice = data.spot_data?.spot_price || data.gamma_data?.spot_price || 0;
            spotPriceChart.data.datasets[0].data.push(spotPrice);
        }
    }

    // Update all charts
    if (futuresChart) futuresChart.update('none');
    if (optionsChart) optionsChart.update('none');
    if (combinedChart) combinedChart.update('none');
    if (srRatioChart) srRatioChart.update('none');
    if (spotPriceChart) spotPriceChart.update('none');

    console.log(`📈 Restored ${dataToRestore.length} data points to all charts including dual-axis futures chart`);
}

    // Clear all persisted data (useful for debugging)
    function clearPersistedData() {
        localStorage.removeItem(STORAGE_KEYS.HISTORICAL_DATA);
        localStorage.removeItem(STORAGE_KEYS.BREAKDOWN_SIGNALS);
        localStorage.removeItem(STORAGE_KEYS.PRICE_REVERSALS);
        localStorage.removeItem(STORAGE_KEYS.LAST_REFRESH);

        historicalData = [];
        allBreakdownSignals = [];
        allPriceReversals = [];

        console.log('🧹 All persisted data cleared');
    }

    // Enhanced fetch data function
    async function fetchData() {
        await fetchEnhancedData();
    }

    // Setup event listeners
    function setupEventListeners() {
        const autoRefreshToggle = document.getElementById('autoRefreshToggle');
        autoRefreshToggle.addEventListener('click', toggleAutoRefresh);
    }

    // Toggle auto refresh
    function toggleAutoRefresh() {
        autoRefresh = !autoRefresh;
        const toggle = document.getElementById('autoRefreshToggle');
        toggle.classList.toggle('active', autoRefresh);

        if (autoRefresh) {
            startAutoRefresh();
        } else {
            clearInterval(refreshInterval);
        }
    }

    // Start auto refresh
    function startAutoRefresh() {
        if (refreshInterval) clearInterval(refreshInterval);
        refreshInterval = setInterval(fetchData, 30000); // 30 seconds
    }

    // Enhanced initialize charts with S/R Ratio and Spot Price charts
    function initializeCharts() {
    const chartOptions = {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
            legend: {
                display: false
            }
        },
        scales: {
            y: {
                grid: {
                    color: 'rgba(255, 255, 255, 0.1)'
                },
                ticks: {
                    color: '#cccccc'
                }
            },
            x: {
                grid: {
                    color: 'rgba(255, 255, 255, 0.1)'
                },
                ticks: {
                    color: '#cccccc'
                }
            }
        }
    };

    // Compact chart options for smaller charts
    const compactChartOptions = {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
            legend: {
                display: false
            }
        },
        scales: {
            y: {
                grid: {
                    color: 'rgba(255, 255, 255, 0.1)'
                },
                ticks: {
                    color: '#cccccc',
                    font: {
                        size: 10
                    }
                }
            },
            x: {
                grid: {
                    color: 'rgba(255, 255, 255, 0.1)'
                },
                ticks: {
                    color: '#cccccc',
                    font: {
                        size: 9
                    },
                    maxTicksLimit: 5
                }
            }
        }
    };

    // Enhanced Futures Chart with Dual Axis
    futuresChart = new Chart(document.getElementById('futuresChart'), {
        type: 'line',
        data: {
            labels: [],
            datasets: [
                {
                    label: 'Weighted Money Flow',
                    data: [],
                    borderColor: '#00d4ff',
                    backgroundColor: 'rgba(0, 212, 255, 0.1)',
                    tension: 0.4,
                    borderWidth: 2,
                    yAxisID: 'y'
                },
                {
                    label: 'Cumulative Flow',
                    data: [],
                    borderColor: '#ff6b6b',
                    backgroundColor: 'rgba(255, 107, 107, 0.05)',
                    tension: 0.4,
                    borderWidth: 3,
                    borderDash: [5, 5],
                    yAxisID: 'y1'
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            interaction: {
                mode: 'index',
                intersect: false,
            },
            plugins: {
                legend: {
                    display: true,
                    position: 'top',
                    labels: {
                        color: '#cccccc',
                        font: {
                            size: 11
                        },
                        usePointStyle: true,
                        pointStyle: 'line'
                    }
                },
                tooltip: {
                    callbacks: {
                        title: function(context) {
                            return context[0].label;
                        },
                        label: function(context) {
                            const label = context.dataset.label;
                            const value = formatNumber(context.parsed.y);
                            return `${label}: ${value}`;
                        }
                    }
                }
            },
            scales: {
                x: {
                    grid: {
                        color: 'rgba(255, 255, 255, 0.1)'
                    },
                    ticks: {
                        color: '#cccccc',
                        maxTicksLimit: 8
                    }
                },
                y: {
                    type: 'linear',
                    display: true,
                    position: 'left',
                    grid: {
                        color: 'rgba(0, 212, 255, 0.2)'
                    },
                    ticks: {
                        color: '#00d4ff',
                        callback: function(value) {
                            return formatNumber(value);
                        }
                    },
                    title: {
                        display: true,
                        text: 'Weighted Money Flow',
                        color: '#00d4ff',
                        font: {
                            size: 10
                        }
                    }
                },
                y1: {
                    type: 'linear',
                    display: true,
                    position: 'right',
                    grid: {
                        drawOnChartArea: false,
                        color: 'rgba(255, 107, 107, 0.2)'
                    },
                    ticks: {
                        color: '#ff6b6b',
                        callback: function(value) {
                            return formatNumber(value);
                        }
                    },
                    title: {
                        display: true,
                        text: 'Cumulative Flow',
                        color: '#ff6b6b',
                        font: {
                            size: 10
                        }
                    }
                }
            }
        }
    });

    // Options Chart (unchanged)
   // Enhanced Options Chart with 4 datasets and dual axis
      // Enhanced Options Chart with 4 datasets and dual axis
     optionsChart = new Chart(document.getElementById('optionsChart'), {
        type: 'line',
        data: {
            labels: [],
            datasets: [
                {
                    label: 'Cumulative Net Flow',
                    data: [],
                    borderColor: '#00ff88',  // Green for cumulative net flow
                    backgroundColor: 'rgba(0, 255, 136, 0.1)',
                    tension: 0.4,
                    borderWidth: 3,
                    fill: false,
                    yAxisID: 'y'  // Left axis for cumulative values
                },
                {
                    label: 'Total Flow',
                    data: [],
                    borderColor: '#00d4ff',  // Blue for total flow
                    backgroundColor: 'rgba(0, 212, 255, 0.05)',
                    tension: 0.4,
                    borderWidth: 2,
                    borderDash: [5, 5],
                    fill: false,
                    yAxisID: 'y1'  // Right axis for individual values
                },
                {
                    label: 'Bullish Flow',
                    data: [],
                    borderColor: '#32cd32',  // Lime green for bullish
                    backgroundColor: 'rgba(50, 205, 50, 0.05)',
                    tension: 0.4,
                    borderWidth: 2,
                    fill: false,
                    yAxisID: 'y1'  // Right axis for individual values
                },
                {
                    label: 'Bearish Flow',
                    data: [],
                    borderColor: '#ff6b6b',  // Red for bearish
                    backgroundColor: 'rgba(255, 107, 107, 0.05)',
                    tension: 0.4,
                    borderWidth: 2,
                    fill: false,
                    yAxisID: 'y1'  // Right axis for individual values
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            interaction: {
                mode: 'index',
                intersect: false,
            },
            hover: {
                mode: 'index',
                intersect: false
            },
            plugins: {
                legend: {
                    display: true,
                    position: 'top',
                    labels: {
                        color: '#cccccc',
                        font: {
                            size: 9
                        },
                        usePointStyle: true,
                        pointStyle: 'line'
                    }
                },
                tooltip: {
                    mode: 'index',
                    intersect: false,
                    callbacks: {
                        title: function(context) {
                            return context[0].label;
                        },
                        label: function(context) {
                            const label = context.dataset.label;
                            const value = formatNumber(context.parsed.y);
                            return `${label}: ${value}`;
                        },
                        afterBody: function(context) {
                            // Add extra spacing and formatting for better readability
                            return '';
                        }
                    },
                    displayColors: true,
                    backgroundColor: 'rgba(0, 0, 0, 0.8)',
                    titleColor: '#ffffff',
                    bodyColor: '#ffffff',
                    borderColor: 'rgba(255, 255, 255, 0.2)',
                    borderWidth: 1
                }
            },
            scales: {
                x: {
                    grid: {
                        color: 'rgba(255, 255, 255, 0.1)'
                    },
                    ticks: {
                        color: '#cccccc',
                        maxTicksLimit: 8
                    }
                },
                y: {
                    type: 'linear',
                    display: true,
                    position: 'left',
                    grid: {
                        color: 'rgba(0, 255, 136, 0.2)'
                    },
                    ticks: {
                        color: '#00ff88',
                        callback: function(value) {
                            return formatNumber(value);
                        }
                    },
                    title: {
                        display: true,
                        text: 'Cumulative Net Flow',
                        color: '#00ff88',
                        font: {
                            size: 9
                        }
                    }
                },
                y1: {
                    type: 'linear',
                    display: true,
                    position: 'right',
                    grid: {
                        drawOnChartArea: false,
                        color: 'rgba(0, 212, 255, 0.2)'
                    },
                    ticks: {
                        color: '#00d4ff',
                        callback: function(value) {
                            return formatNumber(value);
                        }
                    },
                    title: {
                        display: true,
                        text: 'Individual Flows',
                        color: '#00d4ff',
                        font: {
                            size: 9
                        }
                    }
                }
            }
        }
    });

    // Combined Chart (unchanged)
    combinedChart = new Chart(document.getElementById('combinedChart'), {
        type: 'line',
        data: {
            labels: [],
            datasets: [{
                label: 'Combined Signal',
                data: [],
                borderColor: '#ffaa00',
                backgroundColor: 'rgba(255, 170, 0, 0.1)',
                tension: 0.4
            }]
        },
        options: {
            ...chartOptions,
            scales: {
                ...chartOptions.scales,
                y: {
                    ...chartOptions.scales.y,
                    min: -1,
                    max: 1
                }
            }
        }
    });

    // S/R Ratio Chart (unchanged)
    srRatioChart = new Chart(document.getElementById('srRatioChart'), {
        type: 'line',
        data: {
            labels: [],
            datasets: [{
                label: 'S/R Ratio',
                data: [],
                borderColor: '#ff6b6b',
                backgroundColor: 'rgba(255, 107, 107, 0.1)',
                tension: 0.4,
                borderWidth: 2
            }]
        },
        options: {
            ...compactChartOptions,
            scales: {
                ...compactChartOptions.scales,
                y: {
                    ...compactChartOptions.scales.y,
                    min: 0,
                    max: 5
                }
            }
        }
    });

    // Spot Price Chart (unchanged)
    spotPriceChart = new Chart(document.getElementById('spotPriceChart'), {
        type: 'line',
        data: {
            labels: [],
            datasets: [{
                label: 'Spot Price',
                data: [],
                borderColor: '#4ecdc4',
                backgroundColor: 'rgba(78, 205, 196, 0.1)',
                tension: 0.4,
                borderWidth: 2
            }]
        },
        options: compactChartOptions
    });
}


    // Add to window API for debugging
    window.dashboardAPI = {
        updateDashboard: updateDashboard,
        fetchData: fetchData,
        toggleAutoRefresh: toggleAutoRefresh,
        initializeWebSocket: initializeWebSocket,
        clearPersistedData: clearPersistedData,
        saveDataToPersistence: saveDataToPersistence,
        loadPersistedData: loadPersistedData,
        getStoredData: () => ({
            historical: historicalData.length,
            signals: allBreakdownSignals.length,
            reversals: allPriceReversals.length
        })
    };

    console.log('🚀 Enhanced Nifty Dashboard with S/R Ratio and Spot Price Charts Initialized');
    console.log('💾 Data persists across page refreshes');
    console.log('📊 New charts: S/R Ratio and Spot Price trends');
    console.log('🧹 Clear data: dashboardAPI.clearPersistedData()');
</script>

</body>
</html>